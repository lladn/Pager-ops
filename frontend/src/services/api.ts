// frontend/src/services/api.ts
import { incidents, resolvedIncidents, selectedIncident, services } from '../stores';
import type { Incident, Service } from '../types';

// Import Wails Go bindings (these will be generated by Wails)
// Uncomment these when you have your Go backend methods
import { 
  GetIncidents, 
  GetServices, 
  AcknowledgeIncident,
  EscalateIncident,
  ResolveIncident,
  AddIncidentNote,
  GetIncidentDetails
} from '../../wailsjs/go/main/App';

// Mock data for development - replace with actual API calls
const mockServices: Service[] = [
  { id: '1', name: 'API Gateway', abbreviation: 'API', incidentCount: 3, active: true },
  { id: '2', name: 'Database Primary', abbreviation: 'DB', incidentCount: 1, active: true },
  { id: '3', name: 'Web Frontend', abbreviation: 'WEB', incidentCount: 2, active: true },
  { id: '4', name: 'Queue Service', abbreviation: 'Q', incidentCount: 0, active: false },
  { id: '5', name: 'Payment Service', abbreviation: 'PAY', incidentCount: 1, active: true },
];

const mockIncidents: Incident[] = [
  {
    id: 'inc1',
    title: 'Database connection pool exhausted - Critical performance degradation',
    service: 'Database Primary',
    status: 'triggered',
    urgency: 'high',
    createdAt: new Date(Date.now() - 5 * 60000),
    alertCount: 3,
    escalatesIn: 5,
    description: 'Connection pool has reached maximum capacity. Active connections: 100/100.',
    notes: [
      { 
        author: 'John Doe', 
        content: 'Checking database server metrics. CPU at 85%.', 
        timestamp: new Date(Date.now() - 3 * 60000) 
      },
      { 
        author: 'System', 
        content: 'Alert triggered: Connection pool exhausted', 
        timestamp: new Date(Date.now() - 5 * 60000) 
      }
    ]
  },
  {
    id: 'inc2',
    title: 'API Gateway latency spike detected',
    service: 'API Gateway',
    status: 'acknowledged',
    urgency: 'low',
    createdAt: new Date(Date.now() - 12 * 60000),
    alertCount: 1
  },
  {
    id: 'inc3',
    title: 'Payment service timeout errors increasing',
    service: 'Payment Service',
    status: 'acknowledged',
    urgency: 'high',
    createdAt: new Date(Date.now() - 18 * 60000),
    alertCount: 2
  }
];

const mockResolvedIncidents: Incident[] = [
  {
    id: 'inc4',
    title: 'Cache server memory usage normalized',
    service: 'Cache Service',
    status: 'resolved',
    urgency: 'low',
    createdAt: new Date(Date.now() - 45 * 60000),
    alertCount: 1
  }
];

export async function loadServices(): Promise<void> {
  try {
    // Replace with actual API call
    // const response = await GetServices();
    // services.set(response);
    
    // Using mock data for now
    services.set(mockServices);
    updateServiceCounts();
  } catch (error) {
    console.error('Failed to load services:', error);
    throw error;
  }
}

export async function loadIncidents(): Promise<void> {
  try {
    // Replace with actual API calls
    // const openIncidents = await GetIncidents('open');
    // const resolved = await GetIncidents('resolved');
    
    // Using mock data for now
    incidents.set(mockIncidents);
    resolvedIncidents.set(mockResolvedIncidents);
    
    // Select first incident if none selected
    const currentSelected = await new Promise<Incident | null>(resolve => {
      selectedIncident.subscribe(value => resolve(value))();
    });
    
    if (!currentSelected && mockIncidents.length > 0) {
      selectedIncident.set(mockIncidents[0]);
    }
    
    updateServiceCounts();
  } catch (error) {
    console.error('Failed to load incidents:', error);
    throw error;
  }
}

export async function pollData(): Promise<void> {
  try {
    await loadIncidents();
  } catch (error) {
    console.error('Polling error:', error);
  }
}

export async function acknowledgeIncident(incidentId: string): Promise<void> {
  try {
    // Replace with actual API call
    // await AcknowledgeIncident(incidentId);
    
    // Mock implementation
    incidents.update(items => {
      const incident = items.find(i => i.id === incidentId);
      if (incident) {
        incident.status = 'acknowledged';
      }
      return [...items];
    });
  } catch (error) {
    console.error('Failed to acknowledge incident:', error);
    throw error;
  }
}

export async function escalateIncident(incidentId: string): Promise<void> {
  try {
    // Replace with actual API call
    // await EscalateIncident(incidentId);
    
    console.log('Escalating incident:', incidentId);
  } catch (error) {
    console.error('Failed to escalate incident:', error);
    throw error;
  }
}

export async function resolveIncident(incidentId: string): Promise<void> {
  try {
    // Replace with actual API call
    // await ResolveIncident(incidentId);
    
    // Mock implementation
    incidents.update(items => {
      const index = items.findIndex(i => i.id === incidentId);
      if (index >= 0) {
        const resolved = { ...items[index], status: 'resolved' as const };
        items.splice(index, 1);
        
        resolvedIncidents.update(resolved => [resolved, ...resolved]);
      }
      return [...items];
    });
    
    selectedIncident.set(null);
  } catch (error) {
    console.error('Failed to resolve incident:', error);
    throw error;
  }
}

export async function addIncidentNote(incidentId: string, content: string): Promise<void> {
  try {
    // Replace with actual API call
    // await AddIncidentNote(incidentId, content);
    
    // Mock implementation
    const note = {
      author: 'Current User',
      content,
      timestamp: new Date()
    };
    
    incidents.update(items => {
      const incident = items.find(i => i.id === incidentId);
      if (incident) {
        if (!incident.notes) {
          incident.notes = [];
        }
        incident.notes.unshift(note);
      }
      return [...items];
    });
  } catch (error) {
    console.error('Failed to add note:', error);
    throw error;
  }
}

function updateServiceCounts(): void {
  services.update(items => {
    const currentIncidents = [...mockIncidents]; // Get current incidents
    
    items.forEach(service => {
      service.incidentCount = currentIncidents.filter(
        i => i.service === service.name && i.status !== 'resolved'
      ).length;
    });
    
    return [...items];
  });
}