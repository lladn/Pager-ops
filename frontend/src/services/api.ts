// frontend/src/services/api.ts
import { get } from 'svelte/store';
import { incidents, resolvedIncidents, selectedIncident, services } from '../stores';
import type { Incident, Service, Note } from '../types';

// Import Wails Go bindings - These are generated by Wails
import { 
  GetIncidents, 
  GetServices, 
  AcknowledgeIncident,
  EscalateIncident,
  ResolveIncident,
  AddIncidentNote,
  GetIncidentAlerts,
  PinIncident
} from '../../wailsjs/go/main/App';

// Import types from Wails models
import type { database } from '../../wailsjs/go/models';

// Helper function to convert database.Service to frontend Service type
function convertService(dbService: database.Service): Service {
  return {
    id: dbService.id,
    name: dbService.alias || dbService.id, // Use alias as name
    abbreviation: dbService.alias?.substring(0, 3).toUpperCase() || 'SVC',
    incidentCount: 0, // Will be updated by updateServiceCounts
    active: dbService.enabled
  };
}

// Helper function to convert database.CachedIncident to frontend Incident type
function convertIncident(dbIncident: database.CachedIncident): Incident {
  return {
    id: dbIncident.id,
    title: dbIncident.title,
    service: dbIncident.service_id, // Will need to map to service name
    status: dbIncident.status as 'triggered' | 'acknowledged' | 'resolved',
    urgency: dbIncident.urgency as 'high' | 'low',
    createdAt: new Date(dbIncident.created_at),
    alertCount: 0, // Will be updated if needed
    escalatesIn: dbIncident.escalation_level,
    description: dbIncident.description,
    notes: [] // Notes will be fetched separately if needed
  };
}

export async function loadServices(): Promise<void> {
  try {
    const response = await GetServices();
    const convertedServices = response.map(convertService);
    services.set(convertedServices);
    updateServiceCounts();
  } catch (error) {
    console.error('Failed to load services:', error);
    throw error;
  }
}

export async function loadIncidents(): Promise<void> {
  try {
    // Fetch both open and resolved incidents
    const openIncidents = await GetIncidents(['triggered', 'acknowledged']);
    const resolved = await GetIncidents(['resolved']);
    
    // Convert incidents and map service IDs to names
    const servicesList = get(services);
    const serviceMap = new Map(servicesList.map(s => [s.id, s.name]));
    
    const convertedOpen = openIncidents.map(inc => {
      const converted = convertIncident(inc);
      // Map service ID to service name
      converted.service = serviceMap.get(inc.service_id) || inc.service_id;
      return converted;
    });
    
    const convertedResolved = resolved.map(inc => {
      const converted = convertIncident(inc);
      converted.service = serviceMap.get(inc.service_id) || inc.service_id;
      return converted;
    });
    
    incidents.set(convertedOpen);
    resolvedIncidents.set(convertedResolved);
    updateServiceCounts();
  } catch (error) {
    console.error('Failed to load incidents:', error);
    throw error;
  }
}

export async function getIncidentDetails(incidentId: string): Promise<Incident | null> {
  try {
    // Get the incident from the store
    const currentIncidents = get(incidents);
    const incident = currentIncidents.find(i => i.id === incidentId);
    
    if (!incident) {
      // Try to fetch it from resolved
      const resolved = get(resolvedIncidents);
      const resolvedIncident = resolved.find(i => i.id === incidentId);
      if (resolvedIncident) {
        selectedIncident.set(resolvedIncident);
        return resolvedIncident;
      }
      return null;
    }
    
    // Get additional alerts for this incident if needed
    try {
      const alerts = await GetIncidentAlerts(incidentId);
      incident.alertCount = alerts.length;
    } catch (error) {
      console.error('Failed to get incident alerts:', error);
    }
    
    selectedIncident.set(incident);
    return incident;
  } catch (error) {
    console.error('Failed to get incident details:', error);
    throw error;
  }
}

export async function acknowledgeIncident(incidentId: string): Promise<void> {
  try {
    await AcknowledgeIncident(incidentId);
    
    // Update local state
    incidents.update(items => {
      const incident = items.find(i => i.id === incidentId);
      if (incident) {
        incident.status = 'acknowledged';
      }
      return [...items];
    });
  } catch (error) {
    console.error('Failed to acknowledge incident:', error);
    throw error;
  }
}

export async function escalateIncident(incidentId: string, escalationLevel: string = "1"): Promise<void> {
  try {
    await EscalateIncident(incidentId, escalationLevel);
    
    // Update local state
    incidents.update(items => {
      const incident = items.find(i => i.id === incidentId);
      if (incident) {
        incident.status = 'acknowledged'; // Escalated incidents are typically acknowledged
      }
      return [...items];
    });
  } catch (error) {
    console.error('Failed to escalate incident:', error);
    throw error;
  }
}

export async function resolveIncident(incidentId: string): Promise<void> {
  try {
    await ResolveIncident(incidentId);
    
    // Move from active to resolved
    incidents.update(items => {
      const index = items.findIndex(i => i.id === incidentId);
      if (index >= 0) {
        const resolved = { ...items[index], status: 'resolved' as const };
        items.splice(index, 1);
        
        resolvedIncidents.update(resolvedList => [resolved, ...resolvedList]);
      }
      return [...items];
    });
    
    selectedIncident.set(null);
  } catch (error) {
    console.error('Failed to resolve incident:', error);
    throw error;
  }
}

export async function addIncidentNote(incidentId: string, content: string): Promise<void> {
  try {
    await AddIncidentNote(incidentId, content);
    
    // Refresh incident details to get updated notes
    await getIncidentDetails(incidentId);
  } catch (error) {
    console.error('Failed to add note:', error);
    throw error;
  }
}

export async function pinIncident(incidentId: string, pinned: boolean): Promise<void> {
  try {
    await PinIncident(incidentId, pinned);
    
    // Update local state
    incidents.update(items => {
      const incident = items.find(i => i.id === incidentId);
      if (incident) {
        // Add pinned property to incident (you may need to add this to the Incident type)
        (incident as any).pinned = pinned;
      }
      return [...items];
    });
  } catch (error) {
    console.error('Failed to pin/unpin incident:', error);
    throw error;
  }
}

export async function pollData(): Promise<void> {
  try {
    await Promise.all([
      loadIncidents(),
      loadServices()
    ]);
  } catch (error) {
    console.error('Polling failed:', error);
    // Don't throw here to prevent stopping the polling
  }
}

function updateServiceCounts(): void {
  const currentIncidents = get(incidents);
  
  services.update(items => {
    items.forEach(service => {
      service.incidentCount = currentIncidents.filter(
        i => i.service === service.name && i.status !== 'resolved'
      ).length;
    });
    
    return [...items];
  });
}